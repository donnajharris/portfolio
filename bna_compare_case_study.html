<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="stylesheet" href="styles.css">

      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Alkatra&family=Oxygen:wght@300;600;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="css/styles.css">

      <title>Donna J. Harris ~ BNA Compare Case Study</title>

    </head>
    <body>

      <header>
        <h1>Donna J. Harris</h1>
        <nav>
          <div class="flex-nav"><a href="index.html#code-portfolio">Coding</a></div>
          <div class="flex-nav"><a href="index.html#test-portfolio">Testing</a></div>
          <div class="flex-nav"><a href="index.html#work">Work</a></div>
          <div class="flex-nav"><a href="index.html#education">Education</a></div>
          <div class="flex-nav"><a href="index.html#references">References</a></div>
        </nav>

      </header>


      <main>
        <section class="case-study">
          <h2>BNA Compare Case Study</h2>

          <p>While working as a <span class="punch-up">Business Systems Analyst/QA Analyst</span> at Innosphere SDG Ltd., I took the initiative to leverage my technical skills to automate various aspects analysis and testing over the course of multiple years and multiple projects, starting with BNA Compare.</p>

          <p>The BNA Compare utility was created to integrate into existing regulatory library tools. <a href="https://www.prnewswire.com/news-releases/bna-ehs-products-add-new-tool-for-verifying-amendment-updates-125770028.html" target="_blank">Used to verify amendment updates</a> by comparing archived versions of regulatory and legal text.</p>

          <p>In short, the tool could show the differences between two different versions of the same regulation or law, underlining added text and striking out removed text.</p>

          <div class="case-study-stage">
            <h3>UI Test Automation - Visual Testing</h3>

            <h4>The Problem to Solve</h4>
            <p>Initially, the problem was finding ways to avoid boredom. :)</p>
            <p>I also wanted to find appropriate and useful ways to use test automation -- not just do automation for the sake of automating tests.</p>
            <p>The BNA Compare tool had a very basic UI, and made a perfect candidate for exploring UI automation.</p>

            <h4>The Journey</h4>
            <p>While I had more experience with other languages, I decided to try learning Ruby.</p>
            <p>Using Ruby, I...</p>

            <ol>
              <li>Created Watir page objects to automate login and basic version comparisons</li>
              <li>Used Excel/CSV to drive regression (especially comparison) tests</li>
              <li>Setup Selenium Grid with virtual machines to test in different browsers/environments</li>
              <li>Took a screenshot at the end of every test to visually examine the results of the comparison test</li>
            </ol>

            <h4>Advantages</h4>
            <p>I could setup many tests, on many browsers, press a button and walk away and do other things. Then check back on the results later.</p>
            <p>There was a season in the early development where I would need to regress many times in a day. It was awesome to have this effective, time-saving option.</p>

            <h4>Disadvantages</h4>
            <p>Because of the nature of the implementation, the most important tests could not be reliably confirmed with an assertion at the end of the automated steps.</p>

            <h4>Long-term benefits</h4>
            <p>Learning how to drive the UI from CSV and to take screenshots of results was a technique I returned to time and again for several years to come.</p>
          </div>


          <div class="case-study-stage">
            <h3>Code-Level Testing - Supporting the Developer</h3>

            <h4>The Problem to Solve</h4>
            <p>Our original team was small -- just me and one developer -- and the demands on his time were huge.</p>
            <p>He was a huge advocate for adding code-level testing and he wanted to add more, but wasn't finding the time.</p>

            <h4>The Journey</h4>
            <p>Knowing I was technically-inclined, developers often walked through their code with me. On this occasion, he suggested I try adding integration tests based on the one sample he had, testing between intermediary layers of translation.</p>
            <p>Using C#, I...</p>

            <ol>
              <li>Studied the existing NUnit test code, identifying what needed to change to test different cases -- then created one new test manually</li>
              <li>Created a Ruby script for generating the text of a single C# test case for provided parameters</li>
              <li>Used Excel/CSV to list parameters for the C# tests to generate in bulk</li> 
              <li>Added the generated C# tests to the codebase</li>
            </ol>

            <h4>Advantages</h4>
            <p>Even with only a loose grasp of C#, I could create test cases and test code far quicker than the developer could, even if he had the time.</p>
            <p>With the initial dataset in particular, this caught a number of regressions before it even got to me to take a look at.</p>
            <p>I was exposed to the main codebase.</p>

            <h4>Disadvantages</h4>
            <p>It only covered one aspect (although, it was a helpful one!) and had limited value after the code stabilized.</p>

            <h4>Long-term benefits</h4>
            <p>As far as I recall, this specific kind of testing did not carry forward into datasets after the original one -- but its legacy of getting so many of the growing pains of the development approach sorted early definitely carried forward.</p>
            <p>* Note: There would have been other code-level tests in the codebase. I just wasn't involved with creating, running, or maintaining those.</p>
          </div>

          <div class="case-study-stage">
            <h3>Analysis of XML Dataset</h3>

            <h4>The Problem to Solve</h4>
            <p>There was a large amount of archived data versions that were loaded into the initial database. The files were in an XML format and provided many insights into the kind of data we were dealing with.</p>
            <p></p>

            <h4>The Journey</h4>
            <p></p>
            <p>Using Ruby, I...</p>

            <ol>
              <li>Wrote various scripts to interrogate the XML to identify all elements and attributes in existing data</li>
              <li>Created an index of element information to help find real examples of different situtaions</li>
            </ol>

            <h4>Advantages</h4>
            <p>I learned so much about the data by living with it in this way. </p>
            <p>Learned much more about the data than a schema alone could show.</p>

            <h4>Disadvantages</h4>
            <p>Even at the time (2010+), there may have been more efficient ways to interrogate the data than I currently understood.</p>

            <h4>Long-term benefits</h4>
            <p>I was able to take the scripts and skills and apply them with all of the future XML-based datasets. I was also better positioned to ask better questions every time around.</p>
          </div>

          <div class="case-study-stage">
            <h3>Creation of XML Test Data</h3>

            <h4>The Problem to Solve</h4>
            <p>Even with the analysis of the existing data, there were elements and changes between versions that did not exist in the data we had. (The nature of the application meant it was necessary to address elements individually.)</p>
            <p>As a result, we would sometimes find defects in production as new data was added going forward. There would be unhandled situations and unexpected elements. We needed to find more robust ways to avoid this.</p>

            <h4>The Journey</h4>
            <p>Schema in hand, we needed a recipe for tests that would evaluate all possibilities of how an element could be viewed or changed.</p>
            <p>Using Ruby, I...</p>

            <ol>
              <li>Studied the XML data files and determined the smallest possible structure for creating test data -- then created a test file manually</li>
              <li>Created a script to generate test files and scenarios for a provided element</li> 
              <li>Used Excel/CSV to list elements and tests to generate in bulk</li>
              <li>Leveraged the UI test automation code to run a series of tests (with screenshots taken), after loading the generated data to a test server</li>
            </ol>

            <h4>Advantages</h4>
            <p>This was a tremendous help. It became easier to test, faster to test, more thorough, and also trusted by the developers.</p>
            <p>It became possible to hand over the review of the resultant screenshot to a junior team member, who could flag issues.</p>

            <h4>Disadvantages</h4>
            <p>Other than those moments of doubt and anxiety when attmpeting to implement -- "will this be worth it?" ("YES!!") -- there really weren't any.</p>

            <h4>Long-term benefits</h4>
            <p>I was able to take the scripts and skills and apply them with all of the future XML-based dataset testing.</p>
          </div>



          <div class="case-study-stage">
            <h3>New Datasets</h3>

            <h4>The Problem to Solve</h4>
            <p>Following the initial building of BNA Compare and its initial dataset, the tool was rapidly expanded to include other -- differently stuctured -- datasets that needed to be used by the tool.</p>
            <p>The timeline to build was always shorter than desired and the data was always full of new challenges.</p>

            <h4>The Journey</h4>
            <p>Every new dataset became an adventure into unfamiliar territory but with reliable methods and knowledge to guide us.</p>
            <p>Using Ruby and armed with previous experiences, I...</p>

            <ol>
              <li>Leveraged and improved on techniques of analysis and testing for several more BNA Compare datasets</li>
              <li>Leveraged data analysis and test data generation experiences for a totally different XML-like dataset, with good success</li>
            </ol>

            <h4>Advantages</h4>
            <p>It actually got easier to do everytime, and all of the lessons learned from previous experience carried forward.</p>
            <p>It saved so much time and became a trusted approach by the project team.</p>

            <h4>Disadvantages</h4>
            <p>It was easy for some to assume that something would be unreasonably quick to turnaround because of how refined this, and other aspects of development, had become. We still had to do the work of each individual dataset and it could be hard to convince some folk on occasion.</p>

            <h4>Long-term benefits</h4>
            <p>Not only did I use these approaches successfully with BNA Compare, but I also used it with another dataset that was XML-based. It took quite a bit of reworking, but the principles were the same -- as was the end result: Success!</p>
          </div>


        </section>
      </main>


      <footer>
        <p><a href="mailto:hello@donnajharris.xyz">Email</a> | <a href="https://www.github.com/donnajharris" target="_blank">GitHub</a> | <a href="https://www.linkedin.com/in/donnajharris" target="_blank">LinkedIn</a>
        </p>

        <p>Website created by Donna J. Harris. &copy; 2023.</p>
      </footer>


    </body>
</html>