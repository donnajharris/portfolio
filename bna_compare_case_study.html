<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="stylesheet" href="styles.css">
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Alkatra&family=Oxygen:wght@300;600;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="css/styles.css">
      <title>Donna J. Harris ~ BNA Compare Case Study</title>
    </head>
    <body>
      <header>
        <h1>Donna J. Harris</h1>
        <nav>
          <div class="flex-nav"><a href="index.html#code-portfolio">Coding</a></div>
          <div class="flex-nav"><a href="index.html#test-portfolio">Testing</a></div>
          <div class="flex-nav"><a href="index.html#work">Work</a></div>
          <div class="flex-nav"><a href="index.html#education">Education</a></div>
          <div class="flex-nav"><a href="index.html#references">References</a></div>
        </nav>
      </header>
      <main>
        <section class="case-study">
          <h2>BNA Compare Case Study</h2>
          <p>While working as a <span class="punch-up">Business Systems Analyst/QA Analyst</span> at Innosphere SDG Ltd., I took the initiative to leverage my technical skills to automate various aspects of analysis and testing. This was accomplished over the course of several years and multiple projects, all starting with the origin of the <span class="punch-up">BNA Compare</span> project and its US federal regulations dataset.</p>
          <p>The BNA Compare utility was created to integrate into existing regulatory library tools. <a href="https://www.prnewswire.com/news-releases/bna-ehs-products-add-new-tool-for-verifying-amendment-updates-125770028.html" target="_blank">Used to verify amendment updates</a>, the tool could show the differences between two different versions of the same regulation or law, underlining added text and striking out removed text.</p>

          <div class="case-study-stage">
            <h3>UI Test Automation - Visual Testing</h3>

            <h4>The Problem to Solve</h4>
            <p>Initially, the problem was finding ways to avoid boredom. :)</p>
            <p>I also wanted to find appropriate and useful ways to use test automation -- not just do automation for the sake of automating tests.</p>

            <h4>The Journey</h4>
            <p>The BNA Compare tool had a very basic UI, and made a perfect candidate for exploring UI automation.</p>
            <p>While I had more experience with other languages, I decided to try learning Ruby.</p>
            <p>Using Ruby, I...</p>
            <ol>
              <li>Created Watir page objects to automate login and basic version comparisons</li>
              <li>Used Excel/CSV to drive regression (especially comparison) tests</li>
              <li>Setup Selenium Grid with virtual machines to test in different browsers/environments</li>
              <li>Took a screenshot at the end of every test to visually examine the results of the comparison test</li>
            </ol>

            <h4>Advantages</h4>
            <p>I could setup many tests, on many browsers, press a button and walk away and do other things. Then check back on the results later.</p>
            <p>There was a season in the early development where I would need to regress many times in a day. It was awesome to have this effective, time-saving option.</p>

            <h4>Disadvantages</h4>
            <p>Because of the nature of the implementation, the most important tests could not be reliably confirmed with an assertion at the end of the automated steps. Comparison testing still required a quick glance at a screenshot.</p>
            <p>(The design of the test data that evolved over time made this increasingly efficient.)</p>

            <h4>Long-term benefits</h4>
            <p>Learning how to drive the UI from CSV and to take screenshots of results was a technique I returned to time and again for several years to come.</p>
          </div>
          <div class="case-study-stage">
            <h3>Code-Level Testing - Supporting the Developer</h3>

            <h4>The Problem to Solve</h4>
            <p>Our original team was small -- just me and one developer -- and the demands on his time were huge.</p>
            <p>He was a huge advocate for adding code-level testing and he wanted to add more, but wasn't finding the time to increase coverage in the way he envisioned.</p>

            <h4>The Journey</h4>
            <p>Knowing I was technically-inclined, developers often walked through their code with me. On this occasion, he suggested I try adding integration tests based on the one sample he had, testing between intermediary layers of translation.</p>
            <p>Using C# and Ruby, I...</p>
            <ol>
              <li>Studied the existing C# and NUnit test code, identifying what needed to change to test different cases -- then created one new test manually</li>
              <li>Created a Ruby script for generating the text of a single C# test case for provided parameters</li>
              <li>Used Excel/CSV to list parameters for the C# tests to generate in bulk using the Ruby script</li> 
              <li>Added the generated C# tests to the codebase</li>
            </ol>

            <h4>Advantages</h4>
            <p>Even with only a loose grasp of C#, I could create valuable test cases and the corresponding test code far quicker than the developer could, even if he had the time.</p>
            <p>With the initial dataset in particular, this caught a number of regressions before it even got to me to take a look at.</p>
            <p>I was exposed to the main codebase.</p>

            <h4>Disadvantages</h4>
            <p>It only covered one aspect (although, it was a helpful one!) and had limited value after the code stabilized.</p>

            <h4>Long-term benefits</h4>
            <p>As far as I recall, this specific kind of testing did not carry forward into datasets after the original one. But its legacy of working through so many of the growing pains of the development approach resonated into the future.</p>
            <p>* Note: There would have been other code-level tests in the codebase. I just wasn't involved with creating, running, or maintaining those.</p>
          </div>
          <div class="case-study-stage">
            <h3>Analysis of XML Dataset</h3>

            <h4>The Problem to Solve</h4>
            <p>A large amount of archived data versions were loaded into the initial database.</p>
            <p>There was no way to guess what data had examples of any particular element or what surprises or secrets awaited within.</p>

            <h4>The Journey</h4>
            <p>Instead of solely relying on schema documents and the recommendations of subject matter experts to provide insights, I also dug deeper into the data independently.</p>
            <p>Using Ruby, I...</p>
            <ol>
              <li>Wrote various scripts to interrogate the XML in order to identify all elements and attributes in existing data</li>
              <li>Created an index of element information to help find real examples of different situtaions</li>
            </ol>

            <h4>Advantages</h4>
            <p>I learned much more about the data than any schema alone could show.</p>

            <h4>Disadvantages</h4>
            <p>Even at the time (2010+), there may have been more efficient ways to interrogate the data than I currently understood.</p>

            <h4>Long-term benefits</h4>
            <p>I was able to take the scripts and skills and apply them with all of the future XML-based datasets. I was also better positioned to ask better questions every time around.</p>
          </div>
          <div class="case-study-stage">
            <h3>Creation of XML Test Data</h3>

            <h4>The Problem to Solve</h4>
            <p>Even with the analysis of the existing data, there were elements and changes between versions that did not exist in the data we had. (The nature of the application meant it was necessary to address elements individually.)</p>
            <p>As a result, we would sometimes find defects in production as new data was added going forward. There would be unhandled situations and unexpected elements. We needed to find more robust ways to avoid this.</p>

            <h4>The Journey</h4>
            <p>Schema in hand, we needed a recipe for tests that would evaluate all possibilities of how an element could be viewed or changed.</p>
            <p>Using Ruby, I...</p>
            <ol>
              <li>Studied the XML data files and determined the smallest possible structure for creating test data -- then created a test file manually</li>
              <li>Created a script to generate test files and scenarios for a provided element</li> 
              <li>Used Excel/CSV to list elements and tests to generate in bulk</li>
              <li>Leveraged the UI test automation code to run a series of tests (with screenshots taken), after loading the generated data to a test server</li>
            </ol>

            <h4>Advantages</h4>
            <p>This was a tremendous help. It became easier to test, faster to test, more thorough, and also trusted by the developers.</p>
            <p>It became possible to hand over the review of the resultant screenshots to a junior team member, who could flag issues.</p>

            <h4>Disadvantages</h4>
            <p>Other than those moments of doubt and anxiety when attmpeting to implement -- "will this be worth it?" ("YES!!") -- there really weren't any.</p>

            <h4>Long-term benefits</h4>
            <p>I was able to take the scripts and skills and apply them with all of the future XML-based dataset testing.</p>
          </div>
          <div class="case-study-stage">
            <h3>New Datasets</h3>

            <h4>The Problem to Solve</h4>
            <p>Following the initial building of BNA Compare and its first dataset, the tool was rapidly expanded to include other (differently stuctured) datasets.</p>
            <p>The timeline to build was always shorter than desired and the data was always full of new challenges.</p>

            <h4>The Journey</h4>
            <p>Every new dataset became an adventure into unfamiliar territory but with reliable methods and knowledge to guide us.</p>
            <p>Using Ruby and armed with previous experiences, I...</p>
            <ol>
              <li>Leveraged and improved on the previously discussed techniques of analysis and testing for several more BNA Compare datasets</li>
              <li>Leveraged data analysis and test data generation experiences for a non-Compare application with an XML-based dataset</li>
            </ol>

            <h4>Advantages</h4>
            <p>Expanding to inlucde new datasets did become easier to do, and all of the lessons learned from previous experience carried forward.</p>
            <p>These techniques saved so much time and became a trusted approach by the project team.</p>

            <h4>Disadvantages</h4>
            <p>It was easy for some to assume that new data would be unreasonably quick to turnaround because of how refined this, and other aspects of development, had become. We still had to do the work of each individual dataset and it could be hard to convince some folk on occasion.</p>

            <h4>Long-term benefits</h4>
            <p>As mentioned, not only did I use these approaches successfully with BNA Compare, I also used them with aan unrelated web application which had an XML-based dataset. It took quite a bit of reworking, but the principles were the same -- as was the end result: Success!</p>
          </div>
        </section>
      </main>
      <footer>
        <p><a href="mailto:hello@donnajharris.xyz">Email</a> | <a href="https://www.github.com/donnajharris" target="_blank">GitHub</a> | <a href="https://www.linkedin.com/in/donnajharris" target="_blank">LinkedIn</a>
        </p>
        <p>Website created by Donna J. Harris. &copy; 2023.</p>
      </footer>
    </body>
</html>